---
title: 《程序员的自我修养》笔记与思考一
date: 2019-06-05 20:23:51
tags: 笔记
---

#### fork 使用时复制(Copy On Write)
使用fork出的进程，和原任务可以共享内存，只有当需要写入时，会copy一份单独使用。保证效率不会太差。


#### 线程安全

1. 使用原子操作

在不用的操作系统都提供了可以原子操作的方法，CPU也有相应的指令集进行支持。
延展:
在c++11标准中，可以使用std::atmoic来保证对对象操作的原子性

2. 使用锁，条件变量等等

3. 编译优化和cpu动态调度

编译优化:
编译优化导致对象再寄存器中的值没有立即写回。导致数据出错。使用volatile关键字来阻止编译器进行优化。

cpu动态调度:
即使编译出来的代码是按顺序的，cpu执行的顺序不一定会按顺序执行。

思考:
作者在书中介绍，说加锁也不能避免线程安全。这点引起了我的疑惑。在平时PC的编程中，并不常用volatile这个关键字，一般加锁就可以保证。为此，查阅了一下相关资料。

资料:
https://stackoverflow.com/questions/17046558/how-does-a-mutex-ensure-a-variables-value-is-consistent-across-cores

> The consistency across cores is ensured by memory barriers (which also prevents instructions reordering). When you use std::atomic, not only do you access the data atomically, but the compiler (and library) also insert the relevant memory barriers.

> Mutexes work the same way: the mutex implementations (eg. pthreads or WinAPI or what not) internally also insert memory barriers.

这条回答说, 使用std::atmoic和std::mutex都会插入内存屏障, 而内存屏障会保证内核操作的一致性。不会存在乱序调用的情况。
也就是说，内存屏障是锁的一条实现原理。
后面的一条回答，也说到现在的大多数多核处理器(x86和x64), 是保证高速缓存一致的。

那么这个效果，应该是和硬件cpu相关, 在我们平时使用的pc上只需要加锁就可以了。
但是如果是嵌入式设备，不一定支持相关的操作，可能就需要我们手动加入voltaile关键字了

